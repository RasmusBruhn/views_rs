use super::View;

#[derive(Clone, Copy, Debug)]
pub struct ExtentUpdate {
    pub extent_type: ExtentUpdateType,
    pub scale_rel: f32,
    pub scale_abs: f32,
    pub offset_rel: f32,
    pub offset_abs: f32,    
}

#[derive(Clone, Copy, Debug)]
pub enum ExtentUpdateType {
    Stretch(ExtentStretch),
    Locate(ExtentLocate),
}

#[derive(Clone, Copy, Debug)]
pub struct ExtentStretch {
    pub pos1: PositionType,
    pub pos2: PositionType,
}

#[derive(Clone, Copy, Debug)]
pub struct ExtentLocate {
    pub pos: AnchorPoint,
    pub size: SizeType,
}

#[derive(Clone, Copy, Debug)]
pub enum PositionType {
    Anchor(AnchorPoint),
    Set(f32),
}

#[derive(Clone, Copy, Debug)]
pub enum SizeType {
    Stretch(ExtentStretch),
    Relative(RefView),
    Set(f32),
}

#[derive(Clone, Copy, Debug)]
pub struct AnchorPoint {
    pub ref_view: RefView,
    pub ref_point: f32,
}

#[derive(Clone, Copy, Debug)]
pub enum RefView {
    Parent,
    Prev,
    Id(usize),
}

impl RefView {
    /// Tests wether the reference view exists
    /// 
    /// # Parameters
    /// 
    /// siblings: A slice of all the previous siblings of this view
    pub(crate) fn validate(&self, siblings: &[&View]) -> bool {
        match *self {
            // Make sure the index is within the sibling list
            RefView::Id(index) => siblings.len() > index,

            // Make sure the is a sibling if it references the previous
            RefView::Prev => siblings.len() > 0,

            // There is always a parent
            RefView::Parent => true,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ref_view_validate() {
        let view_list = Vec::new();
        
    }
}